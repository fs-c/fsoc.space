<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"></meta><meta name="viewport"  content="width=device-width, initial-scale=1"></meta><meta name="author"  content="fsoc"></meta><meta name="author"  content="Laurenz Weixlbaumer"></meta><link href="/styles/base.css"  rel="stylesheet"></link><link href="/styles/font.css"  rel="stylesheet"></link><title>fsoc.space</title><title>fsoc.space</title><meta name="description"  content="Writing a small patcher to remove ads from an electron app with NodeJS."></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="So I added live reloading to dhow, why do I think this is such a big deal"></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="TODO"></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="Reversing an encryptor written in Java, decidedly overusing streams."></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="TODO"></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="Decrypting file contents by reversing the encryption algorithm."></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link></head><body><div class="min-h-screen flex flex-col h-full "><header class="container border-b border-gray-300 mt-4 mb-4 pb-4"><div class="prose text-black"><a href="/">fsoc</a> / <a href="/words">words</a></div></header><main class="container prose pb-8"><h1 class="mt-4">CrackMe VI: Simple Encryption</h1><aside class="mb-4 flex flex-row justify-between"><small>Last edited on 2022-8-21</small><small><a href="https://github.com/fs-c/fsoc.space/edit/workbench/posts/crackme-6-simple-encryption.md">Edit on github</a></small></aside><p>This is the <a href="https://app.hackthebox.com/challenges/366">"Simple Encryptor"</a> challenge from hackthebox. The download contains an ELF binary ("encrypt") that was used to encrypt another given file ("flag.enc"), containing the flag.</p><p>True to its name, the encryption routine is rather simple.</p><pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  // ...
  
  in_stream = fopen("flag", "rb");
  fseek(in_stream, 0LL, 2);
  size = ftell(in_stream);
  fseek(in_stream, 0LL, 0);
  content = malloc(size);
  fread(content, size, 1uLL, in_stream);
  fclose(in_stream);
  seed[0] = time(0LL);
  srand(seed[0]);
  for ( i = 0LL; i < (__int64)size; ++i )
  {
    *((_BYTE *)content + i) ^= rand();
    v3 = rand();
    v5 = *((_BYTE *)content + i);
    seed[1] = v3 & 7;                           // never used
    *((_BYTE *)content + i) = __ROL1__(v5, v3 & 7);
  }
  out_stream = fopen("flag.enc", "wb");
  fwrite(seed, 1uLL, 4uLL, out_stream);
  fwrite(content, 1uLL, size, out_stream);
  fclose(out_stream);
  return 0;
}</code></pre><p>The encryption routine in prose-pseudocode is</p><pre><code class="language-plaintext">for every character in the input sequence:
    XOR it with (random value 1)
    rotate its bits to the left by ((random value 2) & 7)</code></pre><p>The random number generator is initialized with a seed of <code>time(0)</code> which just <a href="https://man7.org/linux/man-pages/man2/time.2.html">returns the seconds since the epoch</a>. This seed is stored in the first four bytes of the encrypted file. Interestingly, <code>seed</code> in the above IDA snippet is declared as <code>int seed[2]</code>. The first entry is the actual seed, but the second entry changes with every iteration and is never used.</p><p>Writing a decryption routine is straightforward, and consists of performing the inverse of the above steps in reverse order. Care needs to be taken to preserve the order in which the random numbers are generated.</p><pre><code class="language-c">unsigned int seed = *(unsigned int *)buffer;
srand(seed);

for (int i = 4; i < size; i++) {
    int r = rand();

    buffer[i] = __builtin_ia32_rorqi(buffer[i], rand() & 7);

    buffer[i] ^= r;
}</code></pre><p>The trickiest part to this was probably finding <code>__builtin_ia32_rorqi</code> which rotates the bits of the given 8 bit value to the right. Using these builtins <a href="https://gcc.gnu.org/bugzilla//show_bug.cgi?id=92137">is apparently discouraged</a>, but I didn't feel like searching for an alternative considering it's a one-off that worked just fine.</p><h2>Conclusion</h2><p>Figuring out how an algorithm works is always fun. I feel like it could have been a little more complex (even considering the challenges "easy" rating) but I suppose adding more steps would have just made it more tedious, not particularly more difficult.</p><script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script><script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script></main></div><footer class="flex flex-col prose container text-md py-3 mb-1 border-t border-gray-300 mt-4 text-gray-700 font-light"><p>Built with <a href="https://github.com/fs-c/dhow/tree/rewrite">fs-c/dhow</a>, <a href="https://tailwindcss.com/">tailwindcss</a> and <a href="https://rsms.me/inter/">inter</a>.</p><p>Also, <a href="/legal">imprint & privacy</a>.</p></footer></body></html>