<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"></meta><meta name="viewport"  content="width=device-width, initial-scale=1"></meta><meta name="author"  content="fsoc"></meta><meta name="author"  content="Laurenz Weixlbaumer"></meta><link href="/styles/base.css"  rel="stylesheet"></link><link href="/styles/font.css"  rel="stylesheet"></link><meta name="description"  content="Writeup for the filechecker task from the Netzwache CTF 2016."></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="Writeups for two tasks from the Sharif University CTF 2016."></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="Dynamically generating polygons and smoothing out their edges."></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="Writing a small patcher to remove ads from an electron app with NodeJS."></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="So I added live reloading to dhow, why do I think this is such a big deal"></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="Reversing an encryptor written in Java, decidedly overusing streams."></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="TODO"></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="Decrypting file contents by reversing the encryption algorithm."></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="I created a GUI for a side project of mine with minimal effort and convenient usage and you can too!"></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="Reversing modern C++ is weird. Purely static analysis to lift out a flag generation algorithm... again!"></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="I can see you! Reading the flag straight from the file."></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="Purely static analysis to lift out a flag generation algorithm. Fun!"></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link></head><body><div class="min-h-screen flex flex-col h-full "><header class="container border-b border-gray-300 dark:border-gray-600 mt-4 mb-4 pb-4"><div class="prose dark:prose-invert text-black dark:text-white"><a href="/">fsoc</a> / <a href="/words">words</a></div></header><main class="container prose dark:prose-invert lg:prose-lg pb-8"><h1 class="mt-4">CrackMe III: Impossible Password</h1><aside class="mb-4 flex flex-row justify-between"><small>Published on 2022-8-18</small><small><a href="https://github.com/fs-c/fsoc.space/edit/workbench/posts/crackme-3-impossible-password.md">Edit on github</a></small></aside><p>This is the <a href="https://app.hackthebox.com/challenges/26">"Impossible Password"</a> challenge from hackthebox. The file is an ELF binary, so I couldn't run it on my Windows box (without using a VM). It turns out that I didn't need to in any case.</p><p>The start routine nicely cleans up to</p><pre><code class="language-c">int __fastcall main(int a1, char **a2, char **a3)
{
  const char *second_key; // rax
  int result; // eax
  char flag_alphabet[32]; // [rsp+10h] [rbp-40h] BYREF
  char input[20]; // [rsp+30h] [rbp-20h] BYREF
  char *first_key; // [rsp+48h] [rbp-8h]

  first_key = "SuperSeKretKey";
  qmemcpy(flag_alphabet, "A]Kr=9k0=0o0;k1?k81t", 20);
  printf("* ");
  __isoc99_scanf("%20s", input);                // read first input
  printf("[%s]\n", input);
  if ( strcmp(input, first_key) )
    exit(1);
  printf("** ");
  __isoc99_scanf("%20s", input);                // read second input
  second_key = generate_second_key(20);
  result = strcmp(input, second_key);
  if ( !result )
    result = print_flag(flag_alphabet);
  return result;
}</code></pre><p>which reveals the program to be a two-step process: First a trivially readable key is requested. Second, another key is generated and requested. Finally, the flag is printed out.</p><p>Taking a look at the key generation algorithm</p><pre><code class="language-c">BYTE *__fastcall generate_second_key(int size)
{
  int v1; // eax
  _BYTE *buffer; // [rsp+20h] [rbp-10h]
  int i; // [rsp+2Ch] [rbp-4h]

  v1 = time(0LL);
  ++dword_601074;
  srand(size * v1 + dword_601074);
  buffer = malloc(size + 1);
  if ( !buffer )
    exit(1);
  for ( i = 0; i &lt; size; ++i )
    buffer[i] = rand() % 94 + 33;
  buffer[size] = 0;
  return buffer;
}</code></pre><p>reveals that it uses both <code>time</code> and <code>rand</code>, so it is very much nontrivial to generate a key ahead of time. This is presumably also where the challenge gets its name from, it would be impossible for a regular user to get past this check.</p><p>I was basically already resigned to spinning up a Linux box and using a debugger at this point. But taking a look at the flag printing method</p><pre><code class="language-c">// alphabet = A]Kr=9k0=0o0;k1?k81t
int __fastcall print_flag(_BYTE *alphabet)
{
  int i; // eax
  int j; // [rsp+14h] [rbp-Ch]

  j = 0;
  while ( *alphabet != 9 )
  {
    i = j++;
    if ( i &gt; 19 )
      break;
    putchar((char)(*alphabet++ ^ 9));
  }
  return putchar(10);
}</code></pre><p>reveals that nothing about it depends on any random variables. Compiling the above code function and feeding it with the given alphabet prints the correct flag. It's interesting to note that the <code>while</code> loop condition is never true, it's just an anti-reversing decoy. The real loop condition is the check for <code>i &gt; 19</code>.</p><h2>Conclusion</h2><p>This was a really fun one, first time I've used exclusively IDA to solve a crackme. Usually I only understand very little about what is going on in a program when analyzing it, but this one was simple enough to fully grasp in a couple of minutes. That made it more enjoyable I think.</p><p>It would have probably been easier to patch out the offending checks in a debugger and just plow straight to the flag, but this was certainly more interesting.</p><script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script><script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script></main></div><footer class="flex flex-row justify-between prose dark:prose-invert container text-md py-3 mb-1 border-t border-gray-300 dark:border-gray-600 mt-4"><p class="m-0">Built with <a href="https://github.com/fs-c/dhow/tree/rewrite">fs-c/dhow</a>.</p><a href="/legal">imprint & privacy</a></footer></body></html>