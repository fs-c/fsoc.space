<html lang="en"><head><meta charset="utf-8"></meta><meta name="viewport"  content="width=device-width, initial-scale=1"></meta><meta name="author"  content="fsoc"></meta><meta name="author"  content="Laurenz Weixlbaumer"></meta><link href="/styles/base.css"  rel="stylesheet"></link><title>fsoc.space</title><title>fsoc.space</title><title>fsoc.space</title><title>fsoc.space</title><meta name="description"  content="TODO"></meta><meta name="description"  content="Decrypting file contents by reversing the encryption algorithm."></meta><meta name="description"  content="Reversing modern C++ is weird. Purely static analysis to lift out a flag generation algorithm... again!"></meta><meta name="description"  content="I can see you! Reading the flag straight from the file."></meta><meta name="description"  content="I can see you! Reading the flag straight from the file."></meta><meta name="description"  content="Purely static analysis to lift out a flag generation algorithm. Fun!"></meta><meta name="description"  content="Solving a CrackMe wrapped in a well-known game."></meta><meta name="description"  content="Solving a very simple .NET CrackMe using dnSpy."></meta><meta name="description"  content="TODO"></meta><meta name="description"  content="TODO"></meta><meta name="description"  content="Setting up simple and quick (!) C++ unit testing using CMake, Catch2, precompiled headers and (arguably) sneaky tricks."></meta><meta name="description"  content="Short guide to running the game Animal Crossing (which is released exclusively for Nintendo Switch) on a PC."></meta><meta name="description"  content="Using terminal control codes to move the cursor and to draw on the terminal, all from native C code."></meta></head><body><div class="flex-grow "><header class="container border-b border-gray-300 mt-4 mb-3 pb-1"><div class="prose text-black"><a href="/">fsoc</a> / <a href="/words">words</a></div></header><main class="container prose"><h1>Terminal Control Codes (in C)</h1><aside class="mb-2 flex flex-row justify-between"><small>Last edited on 2018-7-26</small><small><a href="https://github.com/fs-c/fsoc.space/edit/workbench/posts/terminal-control-codes-in-c.md">Edit on github</a></small></aside><p><em>Note that basically nothing in this guide is exclusive to the programming language C, anything that can print to a terminal supporting these sequences will work. It's just the language I happened to use them in.</em></p><p>Many terminals (and terminal emulators) support color and cursor control through a system of escape sequences. A commonly supported and used standard is often referred to as "ANSI Colour", on which the VT100 terminal specification which we will be using is based.</p><p>A terminal control code is a special sequence of characters that is sent to <code>stdout</code> (like any other text). If the terminal understands the code it won't display the sequence, but will perform the action which correlates to the code.</p><p>As an example, the code which can be used to erase the screen looks like <code><ESC> [ 2J</code> where <code><ESC></code> represents the ASCII escape character, 27. Spaces are ignored, and can be added for increased readability.</p><p>A more or less complete list of these sequences can be found on <a href="https://web.archive.org/web/20200413124215/http://www.termsys.demon.co.uk/vtansi.htm">termsys.demon.co.uk</a>, but I'll explain the codes used here as we go along.</p><p>Now, the title says "in C", so here goes:</p><pre><code class="language-c">#include <stdio.h>

#define ASCII_ESC 27

int main()
{
    setbuf(stdout, NULL);
    
	printf("%c[2J", ASCII_ESC);

	return 0;
}</code></pre><p>The above snippet uses the code which was already introduced as an example to clear the screen; its behavior is very similar to the <code>CTRL + L</code> shortcut in bash.</p><p>A very important statement to note is the call to <code>setbuf()</code> in line 7, which disables buffering for stdout.</p><p>Having these control codes strewn about in code can only be considered a bad practice, so we're always going to write abstractions for them. This will help readability and make the code cleaner, not to speak of the fact that remembering and always typing these codes out in full can get very annoying, very quickly.</p><p>One such abstraction, which will come in very handy in the next few examples, could be called <code>move_cursor()</code>.</p><pre><code class="language-c">void move_cursor(int x, int y)
{
	printf("%c[%d;%dH", ASCII_ESC, y, x);
}</code></pre><p>The control code to move the cursor naturally has to accept arguments in the form of line and column numbers, which are passed directly after the <code>[</code> and seperated by semicolons. Note that the control code is defined as <code>[{row};{column}H</code>, which is why we first pass <code>y</code>, followed by <code>x</code>. The arguments to <code>move_cursor()</code> could also be called <code>line</code> and <code>column</code>, but I've found <code>x</code> and <code>y</code> to be more intuitive, not to speak of them being much quicker to type.</p><p>In combination with basic stdio functions we can do a great many things with <code>move_cursor()</code>. For example, drawing a line could be done with the following function.</p><pre><code class="language-c">void draw_line(int slope, int width)
{
	for (int i = 0; i < width; i++) {
		move_cursor(i, (slope * -1) * i);

		putchar('#');
	}
}</code></pre><p>The possibilities are endless, and I don't feel like it would add much value if I would provide more examples here -- for an example use case (and implementation) do feel free to read through the code of <a href="https://github.com/LW2904/vt-space">vt-space</a>, a 2D space shooter in the terminal.</p></main></div><footer class="flex flex-row gap-2 prose container text-sm py-2 border-t border-gray-300 mt-4"><span>Built with <a href="https://github.com/fs-c/dhow/tree/rewrite">fs-c/dhow</a>.</span><div class="flex-grow"></div><a href="/imprint">/imprint</a><a href="/privacy">/privacy</a></footer></body></html>