<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"></meta><meta name="viewport"  content="width=device-width, initial-scale=1"></meta><meta name="author"  content="fsoc"></meta><meta name="author"  content="Laurenz Weixlbaumer"></meta><link href="/styles/base.css"  rel="stylesheet"></link><link href="/styles/font.css"  rel="stylesheet"></link><meta name="description"  content="Writeup for the filechecker task from the Netzwache CTF 2016."></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link><meta name="description"  content="Writeups for two tasks from the Sharif University CTF 2016."></meta><link href="/styles/syntax-theme.css"  rel="stylesheet"></link></head><body><div class="min-h-screen flex flex-col h-full "><header class="container border-b border-gray-300 dark:border-gray-600 mt-4 mb-4 pb-4"><div class="prose dark:prose-invert text-black dark:text-white"><a href="/">fsoc</a> / <a href="/words">words</a></div></header><main class="container prose dark:prose-invert lg:prose-lg pb-8"><h1 class="mt-4">SUT CTF 2016: dMd & serial</h1><aside class="mb-4 flex flex-row justify-between"><small>Published on 2022-9-25</small><small><a href="https://github.com/fs-c/fsoc.space/edit/workbench/posts/sharif-ctf-2016-dmd-serial.md">Edit on github</a></small></aside><p>Two challenges today, both from the Sharif University CTF 2016. I usually stick to one per post for ease of reference, but the first one didn't feel like it warranted it's own writeup so I tacked it on to a more interesting one.</p><h2>dMd</h2><p>This is the <code>dMd</code> challenge which I got from <a href="https://github.com/N4NU/Reversing-Challenges-List/blob/master/Baby/Sharif_University_CTF_2016_dMd/README.md">this collection</a> of reversing challenges.</p><p>Opening the single provided file in Binary Ninja reveals it to be an ELF binary. Taking look inside the <code>main</code> function shows that it takes some user input, hashes it with MD5 and (very crudely) compares it to a baked-in hash.</p><figure role="img"><img src="https://i.imgur.com/Vql4sQz.png" alt=""><figcaption></figcaption></figure><p>The expected hash is trivially (if labourously) readable</p><pre><code class="language-plaintext">780438d5b6e29db0898bc4f0225935c0</code></pre><p>I decoded it using a <a href="https://www.md5online.org/md5-decrypt.html">free online service</a>.</p><h2>serial</h2><p>This is the <code>serial</code> challenge, I got it from the same collection as the previous ones. Also like the previous one, the single provided file is an ELF binary.</p><p>But it is significantly less straightforward than its predecessor: Straight off the bat Binary Ninja warns of apparent non-code branches and the pseudocode generation seems off. (Note the checks on seemingly uninitialized variables.)</p><figure role="img"><img src="https://i.imgur.com/IUuFKhJ.png" alt=""><figcaption></figcaption></figure><p>Taking a look at the disassembly reveals the supposed non-code branches to be obviously unreachable by the main code, I would have expected Binary Ninja to catch this.</p><figure role="img"><img src="https://i.imgur.com/dQMR6Fb.png" alt=""><figcaption></figcaption></figure><p>That aside, the initial workings of the executable are straightforward. Like <code>dMd</code> it prompts the user for a key. It then calls <code>strlen</code> to ensure the length of the given key is <code>16</code>.</p><p>After this initial length check follows a pattern of</p><ul><li>ensure character at position <code>x</code> is <code>c</code></li><li>ensure character at position <code>n - x</code> is <code>some constant - c</code></li></ul><p>which is repeated eight time (as expected, for a total of 16 checks). Once this pattern is determined, working out the key is straightforward. I've found the graph view to be useful for this.</p><figure role="img"><img src="https://i.imgur.com/7faHwxS.png" alt=""><figcaption></figcaption></figure><p>Small blocks are the first check, larger blocks the second one. Unreachable code is helpfully absent, and the structure is clearly visible.</p><p>A detail that tripped me up at first is the fact that the input string is stored on the stack, and thus in reverse order&mdash;the first character is at <code>byte [rbp - 0x200]</code>, the last one at <code>byte [rbp - 0x1f1]</code>.</p><h2>Conclusion</h2><p>It was fun to do some reversing again, I got sidetracked with other projects in the past weeks. Still, as mentioned in the preface, the <code>dMd</code> challenge felt lackluster and uninspired&mdash;recovering the hash from the binary (ie. copying down the values) probably took me longer than the rest of the challenge combined.</p><p>The <code>serial</code> challenge was fun, I like that it forced me to not use the pseudocode views for the additional challenge. The input string being stored on the stack probably wasn't intended to make things harder, but I hadn't encountered it before so it added some spice.</p><p>Both challenges are rated <code>baby</code>-level by the guy who maintains the collection where I got them from, and for experienced reverse engineers they probably really are trivial. But at least the second one took me a bit to figure out.</p><script src="https://unpkg.com/prismjs@v1.x/components/prism-core.min.js"></script><script src="https://unpkg.com/prismjs@v1.x/plugins/autoloader/prism-autoloader.min.js"></script></main></div><footer class="flex flex-row justify-between prose dark:prose-invert container text-md py-3 mb-1 border-t border-gray-300 dark:border-gray-600 mt-4"><p class="m-0">Built with <a href="https://github.com/fs-c/dhow/tree/rewrite">fs-c/dhow</a>.</p><a href="/legal">imprint & privacy</a></footer></body></html>