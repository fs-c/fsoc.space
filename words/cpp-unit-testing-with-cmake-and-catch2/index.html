<html lang="en"><head><meta charset="utf-8"></meta><meta name="viewport"  content="width=device-width, initial-scale=1"></meta><meta name="author"  content="fsoc"></meta><meta name="author"  content="Laurenz Weixlbaumer"></meta><link href="/styles/base.css"  rel="stylesheet"></link><title>fsoc.space</title><title>fsoc.space</title><title>fsoc.space</title><title>fsoc.space</title><meta name="description"  content="Reversing an encryptor written in Java, decidedly overusing streams."></meta><meta name="description"  content="TODO"></meta><meta name="description"  content="Decrypting file contents by reversing the encryption algorithm."></meta><meta name="description"  content="The tale of how a side project of mine got a GUI with minimal effort and super convenient usage."></meta><meta name="description"  content="Reversing modern C++ is weird. Purely static analysis to lift out a flag generation algorithm... again!"></meta><meta name="description"  content="I can see you! Reading the flag straight from the file."></meta><meta name="description"  content="Purely static analysis to lift out a flag generation algorithm. Fun!"></meta><meta name="description"  content="Solving a CrackMe wrapped in a well-known game."></meta><meta name="description"  content="Solving a very simple .NET CrackMe using dnSpy."></meta><meta name="description"  content="TODO"></meta><meta name="description"  content="TODO"></meta><meta name="description"  content="Setting up simple and quick (!) C++ unit testing using CMake, Catch2, precompiled headers and (arguably) sneaky tricks."></meta></head><body><div class="flex-grow "><header class="container border-b border-gray-300 mt-4 mb-3 pb-1"><div class="prose text-black"><a href="/">fsoc</a> / <a href="/words">words</a></div></header><main class="container prose"><h1>C++ Unit Testing With CMake and Catch2</h1><aside class="mb-2 flex flex-row justify-between"><small>Last edited on 2020-8-1</small><small><a href="https://github.com/fs-c/fsoc.space/edit/workbench/posts/cpp-unit-testing-with-cmake-and-catch2.md">Edit on github</a></small></aside><p>...and precompiled headers!</p><p>I've used CMake for around a year or so and programmed in C++ for maybe half of that time as of right now, and recently I've finally had a chance to write unit tests for a project of mine. Previous projects were either <a href="https://github.com/fs-c/vt-space">too simple</a> or <a href="https://github.com/fs-c/maniac">too reliant</a> <a href="https://github.com/fs-c/peko">on third party software</a> to warrant the effort but that project really lent itself to it.</p><h2>Problem Statement</h2><p>I wanted the workflow for building and testing the project to be</p><pre><code class="language-plaintext">cd build
cmake ..
make
make test</code></pre><p>and I wanted to see the test output when running <code>make test</code>. This disqualified utilities like <code>CTest</code> since they hide the output of the test driver without proving an option to show it.</p><p>I didn't realize this until I actually ran a test for the first time, but I also want test compiles and runs to be fast. This is why I spent quite a bit of time on figuring out how to precompile the Catch2 header.</p><h2>Solution</h2><p>The unit test folder is split up in two groups: (1) the Catch2 <code>main</code> function and (2) the actual tetst.</p><pre><code class="language-plaintext">└── tests
    ├── catch.h
    ├── CMakeLists.txt
    ├── main.cpp
    └── tests.cpp</code></pre><p><em>Directory listing of the <code>tests</code> folder in my project.</em></p><p><code>main.cpp</code> contains the following two lines</p><pre><code class="language-cpp">#define CATCH_CONFIG_MAIN
#include "catch.h"</code></pre><p>while <code>tests.cpp</code> contains the <code>TEST_CASE</code>s.</p><p>The <code>CMakeLists.txt</code> in the <code>tests/</code> folder contains the following code:</p><pre><code class="language-cmake"># This exclusively contains the catch2 main define, separated because precompiling
# headers would be a problem otherwise.
add_library(tests-main STATIC main.cpp)

# This contains the actual tests.
add_executable(tests-run tests.cpp)

target_link_libraries(tests-run tests-main)

target_compile_definitions(tests-run PRIVATE CATCH_CONFIG_FAST_COMPILE
	CATCH_CONFIG_DISABLE_MATCHERS)

# Important if you don't want the test compile to take >5s every time.
target_precompile_headers(tests-run PRIVATE catch.h)

add_custom_target(test "tests-run" "-d yes")</code></pre><p>The comments in the first couple of lines reveal that the Catch2 <code>main</code> has to be its own file in order to allow headers to be precompiled. The reason for this is sneaky and (in my opinion) borders on being a bug: If <code>CATCH_CONFIG_MAIN</code> is defined, <code>#include "catch.h"</code> expands with the implementation code (which would usually reside in <code>.cpp</code> files), otherwise it expands without it.</p><p>Precompiling would therefore cause the same implementation code to be expanded for all instances of <code>#include "catch.h"</code> and not just the one time it should usually be expanded, leading to linking errors.</p><p>In the above CMake code, this problem is sidestepped by compiling Catch2's <code>main</code> as a library which is then linked to the actual tests. I got this idea from a <a href="http://mochan.info/c++/2019/11/12/pre-compiled-headers-gcc-clang-cmake.html">blog post</a> by Mochan Shrestha, and it works beautifully so far.</p><p>The last line looks simple, and it really is simple: it adds a custom target called <code>target</code> which builds and runs <code>tests-run</code>.</p><p>That's it. <code>make test</code> works as expected. Test compilation is slow for the first compile but really quick afterwards.</p></main></div><footer class="flex flex-row gap-2 prose container text-sm py-2 border-t border-gray-300 mt-4"><span>Built with <a href="https://github.com/fs-c/dhow/tree/rewrite">fs-c/dhow</a>.</span><div class="flex-grow"></div><a href="/imprint">/imprint</a><a href="/privacy">/privacy</a></footer></body></html>