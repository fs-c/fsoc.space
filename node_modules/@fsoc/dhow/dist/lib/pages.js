"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildPages = void 0;
const path_1 = __importDefault(require("path"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const fse = __importStar(require("fs-extra"));
const esbuild = __importStar(require("esbuild"));
const build_1 = require("./build");
const head_1 = require("./head");
const jsx_runtime_1 = require("./jsx-runtime");
// This file modifies process.env with keys of the format `__DHOW_${NAME}`
// since pages may need certain information in special cases. (Pages are 
// built/executed in the same scope as the code in this file.)
const DefaultDocument = (jsx_runtime_1.createElement('html', { lang: 'en' }, jsx_runtime_1.createElement('head', {}, jsx_runtime_1.createElement('meta', { charset: 'utf-8' })), jsx_runtime_1.createElement('body', {})));
const DefaultWrapper = (props = {}) => (jsx_runtime_1.createElement(props.Component, props.pageProps));
const buildJsFile = async (fromFile, toFile) => {
    return esbuild.build({
        entryPoints: [fromFile],
        outfile: toFile,
        // Make sure we can run the built files later
        format: 'cjs',
        platform: 'node',
        // ...without depending on being able to import stuff at runtime
        bundle: true,
        // Support JSX
        loader: { '.js': 'jsx' },
        jsxFactory: 'Dhow.createElement',
        jsxFragment: 'Dhow.Fragment',
        // ...and inject the relevant import into every file
        external: ['dhow'],
        inject: [path_1.default.join(__dirname, '/import-shim.js')],
    });
};
const readPage = (filePath) => {
    // Ensure that code is always re-run since it might have changed since the 
    // last time this was called
    delete require.cache[require.resolve(filePath)];
    try {
        const pageModule = require(filePath);
        const page = {
            default: pageModule.default,
            getPaths: pageModule.getPaths || undefined,
            getProps: pageModule.getProps || (async () => ({})),
        };
        if (typeof page.default !== 'function') {
            throw new Error('does not `export default` a function');
        }
        if (typeof page.getProps !== 'function') {
            throw new Error('has an invalid `getProps` export');
        }
        if (page.getPaths && typeof page.getPaths !== 'function') {
            throw new Error('has an invalid `getPaths` export');
        }
        page.getProps = page.getProps || (() => { });
        return page;
    }
    catch (err) {
        throw new Error(`Malformed page (${filePath}): ${err.message}`);
    }
};
const readComponentLike = (filePath) => {
    try {
        delete require.cache[require.resolve(filePath)];
        const componentModule = require(filePath);
        const component = componentModule.default;
        if (typeof component !== 'function') {
            throw new Error('default export is not a function');
        }
        return component;
    }
    catch (err) {
        if (err.code === 'MODULE_NOT_FOUND') {
            return null;
        }
        throw new Error(`Malformed component (${filePath}): ${err.message}`);
    }
};
const getDocument = (pagesPath) => {
    const custom = readComponentLike(path_1.default.join(pagesPath, '_document.js'));
    if (custom) {
        return custom();
    }
    return DefaultDocument;
};
const getWrapper = (pagesPath) => {
    const custom = readComponentLike(path_1.default.join(pagesPath, '_app.js'));
    if (custom) {
        return custom;
    }
    return DefaultWrapper;
};
const getLocalDependencies = async (filePath) => {
    const content = await fse.readFile(filePath, 'utf8');
    const lines = content.split('\n');
    const dependencies = [];
    for (const line of lines) {
        if (!line.trim().startsWith('import')) {
            continue;
        }
        const normalizedLine = line.replace('"', '\'').replace('`', '\'');
        const dependency = normalizedLine.substring(normalizedLine.indexOf('\'') + 1, normalizedLine.lastIndexOf('\''));
        if (dependency[0] !== '.') {
            continue;
        }
        const parsedFilePath = path_1.default.parse(filePath);
        dependencies.push(path_1.default.resolve(parsedFilePath.dir, dependency.endsWith('.js') ? dependency : dependency + '.js'));
    }
    return dependencies;
};
const pagesCache = {};
const buildPages = async (fromPath, toPath, options) => {
    var _a;
    // Handle deletions of pages
    for (const change of options.changes) {
        if (change.type !== 'unlink' || !change.path.startsWith(fromPath)) {
            continue;
        }
        const cachedPaths = pagesCache[change.path].routePaths;
        if (!cachedPaths.length) {
            build_1.debug('page path cache did not contain expected path %o', change.path);
            continue;
        }
        for (const cachedPath of cachedPaths) {
            await fse.remove(cachedPath);
            build_1.debug('removed cached path %o', cachedPath);
        }
    }
    // Trigger a page rebuild if a dependency of the page changed
    for (const change of options.changes) {
        for (const pagePath of Object.keys(pagesCache)) {
            if ((_a = pagesCache[pagePath]) === null || _a === void 0 ? void 0 : _a.localDependencies.includes(change.path)) {
                options.changes.push({ type: 'change', path: pagePath });
            }
        }
    }
    const stagingPath = path_1.default.join(toPath, '.staging');
    await fse.ensureDir(stagingPath);
    process.env.__DHOW_STAGING_PATH = stagingPath;
    // Build all .js files (pages) to staging (JSX -> regular JS)
    const jsFilePaths = options.initial ? (await fast_glob_1.default(path_1.default.join(fromPath, '**/*.js'))) : (options.changes
        .filter((c) => c.type !== 'unlink' && c.path.startsWith(fromPath))
        .map((change) => change.path));
    if (!jsFilePaths.length) {
        build_1.debug('skipping page building since there are no new files to build');
        return;
    }
    else {
        build_1.debug('building js files %o', jsFilePaths);
    }
    build_1.debug('getting local dependencies of js files');
    for (const filePath of jsFilePaths) {
        if (!pagesCache[filePath]) {
            pagesCache[filePath] = {
                routePaths: [],
                localDependencies: [],
            };
        }
        pagesCache[filePath].localDependencies =
            await getLocalDependencies(filePath);
        build_1.debug('local dependencies of %o are %o', filePath.slice(fromPath.length), pagesCache[filePath].localDependencies);
    }
    build_1.debug('transpiling js files to %o', stagingPath);
    const jsBuildResults = await Promise.all(jsFilePaths.map((filePath) => buildJsFile(filePath, path_1.default.join(stagingPath, filePath.slice(fromPath.length)))));
    for (const result of jsBuildResults) {
        for (const warning of result.warnings) {
            build_1.debug('%o', warning);
        }
    }
    // Set up the document (VNode tree) into which built html will be inserted
    const document = getDocument(stagingPath);
    const documentEntry = document.find({ id: 'dhow' })
        || document.find({ type: 'body' });
    const documentHead = document.find({ type: 'head' });
    if (!documentEntry) {
        throw new Error('Invalid document, no entry point found.');
    }
    if (!documentHead) {
        throw new Error('Invalid document, no head found.');
    }
    // Get the component which will wrap all pages 
    const Wrapper = getWrapper(stagingPath);
    // Get the paths to all pages (all .js files in staging)
    const pagePaths = await fast_glob_1.default(path_1.default.join(stagingPath, '**/*.js'));
    build_1.debug('building pages at the paths %o', pagePaths);
    for (const pagePath of pagePaths) {
        const parsedPagePath = path_1.default.parse(pagePath);
        process.env.__DHOW_PAGE_PATH = pagePath;
        process.env.__DHOW_PAGE_DIR = parsedPagePath.dir;
        if (['_app', '_document'].includes(parsedPagePath.name)) {
            continue;
        }
        const pageDir = parsedPagePath.dir.slice(stagingPath.length);
        const page = readPage(pagePath);
        // Compute all routes (all folders where a .html file will eventually 
        // be generated to
        const routePaths = page.getPaths ? ((await page.getPaths()).map((p) => path_1.default.join(pageDir, p))) : ([parsedPagePath.name === 'index' ? pageDir : parsedPagePath.name]);
        // The `cacheKey` is really just the path of the original .js file
        const cacheKey = path_1.default.join(fromPath, pagePath.slice(stagingPath.length));
        if (!pagesCache[cacheKey]) {
            pagesCache[cacheKey] = { routePaths: [], localDependencies: [] };
        }
        for (const routePath of routePaths) {
            process.env.__DHOW_ROUTE_PATH = routePath;
            // Strip the previously prepended pageDir from the routePath since 
            // getProps expects the values that were returned from getPaths
            const props = await page.getProps(routePath.slice(pageDir.length));
            const html = jsx_runtime_1.createElement(Wrapper, {
                Component: page.default, pageProps: props
            }).toString();
            documentEntry.children = [html];
            if (head_1.head.contents) {
                documentHead.children.push(...head_1.head.contents);
                head_1.head.contents = [];
            }
            const htmlPath = path_1.default.join(toPath, routePath, 'index.html');
            await fse.outputFile(htmlPath, document.toString());
            if (!pagesCache[cacheKey].routePaths.includes(htmlPath)) {
                pagesCache[cacheKey].routePaths.push(htmlPath);
            }
        }
    }
    await fse.remove(stagingPath);
};
exports.buildPages = buildPages;
